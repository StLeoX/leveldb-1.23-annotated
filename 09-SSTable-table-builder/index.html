<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SSTable(04)—Table Builder - leveldb-1.23-annotated</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../INDEX.html"><strong aria-hidden="true">1.</strong> 目录</a></li><li class="chapter-item expanded "><a href="../01-introduction/index.html"><strong aria-hidden="true">2.</strong> leveldb 概述与 LSM-Tree</a></li><li class="chapter-item expanded "><a href="../02-data-structure/index.html"><strong aria-hidden="true">3.</strong> leveldb 中的常用数据结构</a></li><li class="chapter-item expanded "><a href="../03-varint-and-key-format/index.html"><strong aria-hidden="true">4.</strong> leveldb 中的 varint 与 Key 组成</a></li><li class="chapter-item expanded "><a href="../04-write-process/index.html"><strong aria-hidden="true">5.</strong> leveldb Key-Value 写入流程分析</a></li><li class="chapter-item expanded "><a href="../05-WAL/index.html"><strong aria-hidden="true">6.</strong> leveldb 预写日志格式及其读写流程</a></li><li class="chapter-item expanded "><a href="../06-SSTable-data-block/index.html"><strong aria-hidden="true">7.</strong> SSTable(01)—概览与 Data Block</a></li><li class="chapter-item expanded "><a href="../07-SSTable-meta-block/index.html"><strong aria-hidden="true">8.</strong> SSTable(02)—Bloom Filter 与 Meta Block</a></li><li class="chapter-item expanded "><a href="../08-SSTable-index/index.html"><strong aria-hidden="true">9.</strong> SSTable(03)—SSTable 之索引</a></li><li class="chapter-item expanded "><a href="../09-SSTable-table-builder/index.html" class="active"><strong aria-hidden="true">10.</strong> SSTable(04)—Table Builder</a></li><li class="chapter-item expanded "><a href="../10-minor-compaction/index.html"><strong aria-hidden="true">11.</strong> Compaction(01)—Minor Compaction</a></li><li class="chapter-item expanded "><a href="../11-version-control-overview/index.html"><strong aria-hidden="true">12.</strong> leveldb 版本控制概览</a></li><li class="chapter-item expanded "><a href="../12-major-compaction/index.html"><strong aria-hidden="true">13.</strong> Compaction(02)—Major Compaction</a></li><li class="chapter-item expanded "><a href="../13-snapshot-and-backup/index.html"><strong aria-hidden="true">14.</strong> Snapshot 快照与备份</a></li><li class="chapter-item expanded "><a href="../14-read-path/index.html"><strong aria-hidden="true">15.</strong> leveldb Key-Value 读取流程分析</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">leveldb-1.23-annotated</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sstabletable-builder"><a class="header" href="#sstabletable-builder">SSTable—Table Builder</a></h1>
<p>在前面我们已经完成了 Data Block、Filter Block 以及 Metaindex Block、Index Block 的构建过程梳理，那么最后需要做的事情就是将这些构建过程串联起来，得到一个完成的 SSTable。</p>
<h2 id="1-table-builder"><a class="header" href="#1-table-builder">1. Table Builder</a></h2>
<p>和 <code>BlockBuilder</code>、<code>FilterBlockBuilder</code> 的命名方式一样，构建 SSTable 的类名称叫做 <code>TableBuilder</code>，其内部将 <code>BlockBuilder</code>、<code>FilterBlockBuilder</code> 等内容组合起来，以构建 SSTable。</p>
<pre><code class="language-cpp">class LEVELDB_EXPORT TableBuilder {
public:
    /* WritableFile 通常为 PosixWritableFile */
    TableBuilder(const Options&amp; options, WritableFile* file);
    
    /* 向 TableBuilder 中添加 Key-Value，这里的 Key 同样为 InternalKey */
    void Add(const Slice&amp; key, const Slice&amp; value);
    
    /* 将缓冲区中的数据 flush 到文件中，由 leveldb 内部调用 */
    void Flush();
    
    Status status() const;
    
    /* 结束 Table 的构建 */
    Status Finish();
    
    /* 放弃 Table 的构建 */
    void Abandon();
    
    /* 一共添加了多少 Key-Value 对 */
    uint64_t NumEntries() const;

private:
    bool ok() const { return status().ok(); }
    /* 序列化需要写入的 Data Block */
    void WriteBlock(BlockBuilder* block, BlockHandle* handle);
    /* 将压缩后的数据写入文件中 */
    void WriteRawBlock(const Slice&amp; data, CompressionType, BlockHandle* handle);
    
    /* Rep 的作用就是隐藏具体实现 */
    struct Rep;
    Rep* rep_;
};
</code></pre>
<p><code>TableBuilder</code> 对外提供的接口非常简洁，主要就是 <code>Add()</code>、<code>Flush()</code> 以及 <code>Finish</code> 这三个方法的调用，并且从名称上来看我们也能够大致地猜测出方法的功能。 在 <code>TableBuilder</code> 中只有唯一的一个成员变量 <code>rep_</code>，其类型为 <code>Rep *</code>。<code>Rep_</code> 这个结构体的作用就是做了另一层的封装，能够让 <code>TableBuilder</code> 这个类更清爽一些:</p>
<pre><code class="language-cpp">struct TableBuilder::Rep {
  
    Options options;              /* Data Block Options */
    Options index_block_options;  /* Index Block Options */
    WritableFile* file;           /* 抽象类，决定了如何进行文件的写入，PosixWritableFile */
    uint64_t offset;              /* Data Block 在 SSTable 中的文件偏移量 */
    Status status;                /* 操作状态 */
    BlockBuilder data_block;      /* 构建 Data Block 所需的 BlockBuilder */
    BlockBuilder index_block;     /* 构建 Index Block 所需的 BlockBuilder */
    std::string last_key;         /* 当前 Data Block 的最后一个写入 key */
    int64_t num_entries;          /* 当前 Data Block 的写入数量 */
    bool closed;                  /* 构建过程是否结束 */
    FilterBlockBuilder* filter_block; /* 构建 Filter Block 所需的 BlockBuilder */
    
    bool pending_index_entry;     /* pending_index_entry 用于 Add() 方法中 */
    BlockHandle pending_handle;  // Handle to add to index block
    
    std::string compressed_output;  /* 压缩之后的 Data Block */
};
</code></pre>
<p><code>TableBuilder</code> 中各个方法的调用关系如下图所示:</p>
<p><img src="images/1629785831938.png" alt="Alt text" /></p>
<h2 id="2-tablebuilderadd"><a class="header" href="#2-tablebuilderadd">2. <code>TableBuilder::Add()</code></a></h2>
<p>在实际地向 Data Block 和 Filter Block 添加数据之前，需要进行基本的逻辑判断，比如说当前 Build 过程是否结束，也就是是否已经调用了 <code>Finish()</code> 或者是 <code>Abandon()</code> 方法。另一点就是需要保证当前添加的 Key 一定是大于 <code>last_key</code> 的，保证 Data Block 的有序性:</p>
<pre><code class="language-cpp">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) {
    Rep* r = rep_;
    assert(!r-&gt;closed);     /* 判断当前 Build 过程是否结束 */
    if (!ok()) return;
    if (r-&gt;num_entries &gt; 0) {
        /* 判断当前 key 是否大于 last_key */
        assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; 0);
    }
}
</code></pre>
<p>紧接着，就是对 <code>pending_index_entry</code> 进行判断。<code>pending_index_entry</code> 是一个布尔型的标志位，用于表示是否到了生成 Index Block 的时机，如果 <code>pending_index_entry</code> 为 <code>true</code> 的话，那么就去生成 Index Block，否则继续构建 Data Block 和 Filter Block。那么 <code>pending_index_entry</code> 什么时候为 <code>true</code> 呢？答案就是在写完一个 Data Block 之后:</p>
<pre><code class="language-cpp">/* Data Block 的默认大小为 4KB */
if (estimated_block_size &gt;= r-&gt;options.block_size) {
    /* Flush() 方法内部将会把 pending_index_entry 置为 True */
    Flush();
}
</code></pre>
<p><strong>也就是说，当 <code>Add()</code> 方法在写入下一个 Data Block 的第一个 Key-Value 对时，才会为上一个 Data Block 构建 Index Block</strong>，这一点作者在原注释中已经解释了。其根本目的就是使用更短的 Key 来作为 Index Block 的 Key。比如说上一个 Data Block 的数据为 <code>[&quot;smart&quot;, &quot;split&quot;, &quot;slice&quot;, &quot;string&quot;]</code>，排序后得到 <code>['slice', 'smart', 'split', 'string']</code>。因此，&quot;string&quot; 就是上一个 Data Block 的结束边界，如果说当前 Data Block 的起始边界为 &quot;sword&quot; 的话，<strong>那么就可以使用 &quot;su&quot; 来作为上一个 Data Block 的 Index Block Key</strong>。因为 &quot;su&quot; 大于 &quot;string&quot;，并且小于 &quot;sword&quot;。这么做并不会影响搜索，同时节省了磁盘存储空间，一个非常巧妙的设计。</p>
<pre><code class="language-cpp">/* 在构建下一个 Data Block 之前，将 Index Block 构建出来 */
if (r-&gt;pending_index_entry) {
    /* 当前 Data Block 必然为空 */
    assert(r-&gt;data_block.empty());
    
    /* 通过 last_key 和 当前 key 计算得到一个 X，使得 last_entry &lt;= X &lt; key  */
    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);
    std::string handle_encoding;
    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
    
    /* 向 Index Block 中添加上一个 Data Block 的 Index */
    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
    
    /* 上一个 Data Block 的 Index Block 已经写完，故更新 pending_index_entry 为 false */
    r-&gt;pending_index_entry = false;
}
</code></pre>
<p><img src="images/1629775557520.png" alt="Alt text" /></p>
<p>我们可以在 <code>InternalKeyComparator::FindShortestSeparator()</code> 这个方法中去检验当我们传入不同的 <code>last_key</code> 和 <code>key</code> 得到的 Index Block Key 是否是满足基本要求的。</p>
<p>不管是否需要写入 Index Block，Data Block 和 Filter Block 都是需要写入的，那么 <code>Add()</code> 方法下面的流程就是调用 <code>FilterBlockBuilder</code> 和 <code>BlockBuilder</code> 的相关方法写入 Internal Key 和 User Value:</p>
<pre><code class="language-cpp">/* 若指定了 FilterPolicy，那么就会写入 Filter Block */
if (r-&gt;filter_block != nullptr) {
    r-&gt;filter_block-&gt;AddKey(key);
}

/* 更新 last_key */
r-&gt;last_key.assign(key.data(), key.size());
/* 更新 Key-Value 写入数量 */
r-&gt;num_entries++;
/* 将数据添加至 Data Block 中 */
r-&gt;data_block.Add(key, value);
</code></pre>
<p>最后，如果当前 Data Block 的预估大小（未进行压缩之前的大小）超过了 <code>Options.block_size</code> 阈值的话，那么就会调用 <code>Flush()</code> 方法结束当前 Block 的构建:</p>
<pre><code class="language-cpp">/* Data Block 的默认大小为 4KB */
const size_t estimated_block_size = r-&gt;data_block.CurrentSizeEstimate(); 
if (estimated_block_size &gt;= r-&gt;options.block_size) {
    /* 结束当前 Block 的构建，Flush() 方法内部将会把 pending_index_entry 置为 True */
    Flush();
}
</code></pre>
<h2 id="3-tablebuilderflush"><a class="header" href="#3-tablebuilderflush">3. <code>TableBuilder::Flush()</code></a></h2>
<p><code>Flush()</code> 方法结束当前 Data Block 的构建，其调用时机我们在 <code>Add()</code> 方法中已经分析过了，即当 Data Block 的预估大小超过了 <code>Options.block_size</code> 时，将会调用 <code>Fulsh()</code> 方法。在该方法内部，将会对 Data Block 进行压缩，leveldb 默认使用 snappy 压缩方法，同样是 Google 的开源项目: <a href="https://github.com/google/snappy">snappy</a>:</p>
<pre><code class="language-cpp">void TableBuilder::Flush() {
    Rep* r = rep_;
    assert(!r-&gt;closed);
    if (!ok()) return;
    if (r-&gt;data_block.empty()) return;
    assert(!r-&gt;pending_index_entry);
    
    /* 对 Data Block 进行压缩，并生成 Block Handle */
    WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);
    if (ok()) {
        /* 设置 pending_index_entry 为 true，下一次写入 Data Block 时，需构建 Index Block */
        r-&gt;pending_index_entry = true;
        /* 将数据写入至内核缓冲区 */
        r-&gt;status = r-&gt;file-&gt;Flush();
    }
    if (r-&gt;filter_block != nullptr) {
        /* 创建一个新的 Filter Block */
        r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);
    }
}
</code></pre>
<p><code>Flush()</code> 方法本身比较简单，最为核心的调用为 <code>WriteBlock()</code>，这也是 <code>TableBuilder</code> 的私有方法之一，和 <code>WriteRawBlock()</code> 搭配使用。</p>
<h2 id="4-tablebuilderwriteblock-与-tablebuilderwriterawblock"><a class="header" href="#4-tablebuilderwriteblock-与-tablebuilderwriterawblock">4. <code>TableBuilder::WriteBlock()</code> 与 <code>TableBuilder::WriteRawBlock()</code></a></h2>
<p>在 <code>WriteBlock()</code> 方法中，主要对 Data Block 进行 snappy 压缩，同时，如果压缩率低于 12.5% 的话，将不会使用 snappy 压缩，直接存储原数据:</p>
<pre><code class="language-cpp">void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
    Rep* r = rep_;
    /* 获取 Data Block 的全部数据 */
    Slice raw = block-&gt;Finish();
    Slice block_contents;
    
    /* 默认压缩方式为 kSnappyCompression */
    CompressionType type = r-&gt;options.compression;
    
    switch (type) {
        case kNoCompression:
              block_contents = raw;
              break;

        case kSnappyCompression: {
            std::string* compressed = &amp;r-&gt;compressed_output;

            /* 进行 snappy 压缩，并且只有在压缩率大于 12.5 时才会选用压缩结果 */
            if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;
                compressed-&gt;size() &lt; raw.size() - (raw.size() / 8u)) {
                    block_contents = *compressed;
            } else {
                /* 未配置压缩算法，或者是使用 snappy 压缩时压缩率低于 12.5% */
                block_contents = raw;
                type = kNoCompression;
            }
            break;
        }
    }
    /* 将处理后的 block contents、压缩类型以及 block handle 写入到文件中 */
    WriteRawBlock(block_contents, type, handle);
    /* 清空临时存储 buffer */
    r-&gt;compressed_output.clear();
    /* 清空 Data Block */
    block-&gt;Reset();
}
</code></pre>
<h2 id="5-tablebuilderfinish"><a class="header" href="#5-tablebuilderfinish">5. <code>TableBuilder::Finish()</code></a></h2>
<p>最后再来看 <code>Finish()</code> 方法，该方法表示已经将所有的 Key-Value 添加至 SSTable 中，并进行一些收尾工作，例如写入 Metaindex Block，Footer 等。整个 <code>Finish()</code> 方法的逻辑非常清晰，大体上可以分为 5 个部分:</p>
<p>首先调用 <code>TableBuilder::Flush()</code> 方法将最后一个 Data Block 写入，由于最后一个 Data Block 可能只有少数几个 Key-Value，无法自行触发 <code>Flush()</code> 方法的调用，因此需要主动地再次调用:</p>
<pre><code class="language-cpp">Rep* r = rep_;
/* 将最后一个 Data Block 写入 */
Flush();
assert(!r-&gt;closed);
/* 更新关闭标志位为 true */
r-&gt;closed = true;
</code></pre>
<p>紧接着，将 Filter Block 写入:</p>
<pre><code class="language-cpp">// Write filter block
  if (ok() &amp;&amp; r-&gt;filter_block != nullptr) {
    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,
                  &amp;filter_block_handle);
  }
</code></pre>
<p>然后，写入 Metaindex Block，并添加 &quot;filter.leveldb.BuiltinBloomFilter2&quot; 到 Metaindex Block 中，以快速定位 Filter Data:</p>
<pre><code class="language-cpp">if (ok()) {
    BlockBuilder meta_index_block(&amp;r-&gt;options);
    if (r-&gt;filter_block != nullptr) {
        std::string key = &quot;filter.&quot;;
        /* 若使用 Bloom Filter，key 的值为 filter.leveldb.BuiltinBloomFilter2 */
        key.append(r-&gt;options.filter_policy-&gt;Name());
        std::string handle_encoding;
        filter_block_handle.EncodeTo(&amp;handle_encoding);
        meta_index_block.Add(key, handle_encoding);
    }

    /* 写入 Metaindex Block */
    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);
}
</code></pre>
<p>最后，将 Index Block 和 Footer 写入即可，整个 SSTable 的构建过程也就结束了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../08-SSTable-index/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../10-minor-compaction/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../08-SSTable-index/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../10-minor-compaction/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
